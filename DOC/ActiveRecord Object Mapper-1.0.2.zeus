##|TYPE Template
##|UNIQUEID aa190353-4e0b-421e-b237-51e4cf724f59
##|TITLE ActiveRecord Object Mapper-1.0.2
##|NAMESPACE ActiveRecord
##|SOURCE_TYPE Source
##|OUTPUT_LANGUAGE C#
##|COMMENTS_BEGIN
This is an activerecord class generator from existing database schema. Orginalscript is from NHibernate Mapping (ref: k-dub). This uses NHibernate Generics with EntitySet support. Mappings on one-to-one, one-to-many and many-to-many are supported. -GPB
##|COMMENTS_END
##|GUI_ENGINE .Net Script
##|GUI_LANGUAGE C#
##|GUI_BEGIN
<%#REFERENCE System.Windows.Forms.dll %>
<%#NAMESPACE System, System.Text, System.Collections, Zeus, Zeus.UserInterface, Zeus.DotNetScript %>

public class GeneratedGui : DotNetScriptGui
{
	public GeneratedGui( ZeusGuiContext context ) : base( context ) {}

	public override void Setup()
	{
		if ( !input.Contains( "chooseTables" ) || !input.Contains( "txtPath" ) ||
				( !input.Contains( "chkClass" ) && !input.Contains( "chkNaming" ) ) )
		{
			ui.Title = "ActiveRecord Object Mapper-1.0.2";
			ui.Width = 600;
			ui.Height =600;
	
			// Grab default output path
			string sOutputPath = "";
			
			if( input.Contains( "defaultOutputPath" ) ) 
			{
				sOutputPath = input["defaultOutputPath"].ToString();
			}

			// Setup Folder selection input control.
			GuiLabel label1 = ui.AddLabel( "label1", "Output path:", "Select the output path in the field below." );
			label1.Width =75;
			GuiTextBox outputPath = ui.AddTextBox( "outputPath", sOutputPath, "Select the Output Path." );
			outputPath.Width = 250;
			
			outputPath.Left = label1.Left + label1.Width;
			outputPath.Top = label1.Top;
			GuiFilePicker selectPath = ui.AddFilePicker( "selectPath", "Select Path", "Select the Output Path.", "outputPath", true );
			selectPath.Top = outputPath.Top;
			selectPath.Width = 100;
			selectPath.Left = outputPath.Left + outputPath.Width + 5;
			
			GuiLabel label2 = ui.AddLabel( "label2", "Namespace: ",  "Provide your objects namespace." );
			label2.Width = 75;
			GuiTextBox classNamespace = ui.AddTextBox( "classNamespace", "ActiveRecord.Model", "Provide your objects namespace." );				
			classNamespace.Width = 150;
			classNamespace.Top = label2.Top;
			classNamespace.Left = outputPath.Left;//label2.Left + label2.Width + 5;
			
			
			
            GuiLabel label3 = ui.AddLabel( "label3", "Var Prefix: ", "Provide your Prefix." );
			label3.Width = 75;
			label3.Top = label2.Top;
			label3.Left = classNamespace.Left + classNamespace.Width + 15;
			GuiTextBox memberPrefix = ui.AddTextBox( "memberPrefix", "", "" );
			memberPrefix.Width = 150;
			memberPrefix.Top = classNamespace.Top;
			memberPrefix.Left = label3.Left + label3.Width + 5;
             
			 //Using
			GuiLabel lblUsing = ui.AddLabel( "lblUsing", "Using: ",  "Provide your custom using ...;" );
			lblUsing.Width = 75;
			GuiTextBox classUsing = ui.AddTextBox( "classUsing", "", "Provide your custom using ..." );				
			classUsing.Width = 150;
			classUsing.Top = lblUsing.Top;
			classUsing.Left  = outputPath.Left;//lblUsing.Left + lblUsing.Width+ 5;
			
			// Setup Database selection combobox.
			GuiLabel label4 = ui.AddLabel( "label4", "Select a DB:", "Select a database in the dropdown below." );
			label4.Width = 75;
			label4.Top = lblUsing.Top;
			label4.Left = classUsing.Left + classUsing.Width+5;
			GuiComboBox chooseDatabase = ui.AddComboBox( "chooseDatabase", "Select a database." );
			chooseDatabase.Width = 200;
			chooseDatabase.Top = label4.Top;
			chooseDatabase.Left = memberPrefix.Left;//abel4.Left + label4.Width+5;
			
			 //Using
			GuiLabel lblDBPrefix = ui.AddLabel( "lblDBPrefix", "Tab. Prefix from.: ",  "Table prefix to remove ...;" );
			lblDBPrefix.Width = 100;
			//lblDBPrefix.Top = lblDBPrefix.Top + 10;
			GuiTextBox classDBPrefix = ui.AddTextBox( "classDBPrefix", "", "Table prefix to remove ..." );				
			classDBPrefix.Width = 110;
			classDBPrefix.Top = lblDBPrefix.Top;
			classDBPrefix.Left  = outputPath.Left + 40;;//lblUsing.Left + lblUsing.Width+ 5;
			
			// Setup Database selection combobox.
			GuiLabel labelDBPrefixSub = ui.AddLabel( "labelDBPrefixSub", " To :", "Select a database in the dropdown below." );
			labelDBPrefixSub.Width = 75;
			labelDBPrefixSub.Top = lblDBPrefix.Top;
			labelDBPrefixSub.Left = classDBPrefix.Left + classDBPrefix.Width+5;
			GuiTextBox classDBPrefixRpl = ui.AddTextBox( "classDBPrefixRpl", "", "Table prefix to remove ..." );				
			classDBPrefixRpl.Width = 150;
			classDBPrefixRpl.Top = labelDBPrefixSub.Top;
			classDBPrefixRpl.Left  = memberPrefix.Left;//lblUsing.Left + lblUsing.Width+ 5;
			
			
			
			GuiLabel label5 = ui.AddLabel( "label5", "Output type:", "Select one or both." );
			label5.Width = 75;
			//label5.Top = label4.Top;
			//label5.Left = label4.Width + 20;
			GuiCheckBox chkClass = ui.AddCheckBox( "chkClass", "Create class files.", true, "Create a class file for each table or view selected. (*.cs)" );
			chkClass.Width = 150;
			chkClass.Top = label5.Top;
			chkClass.Left = label5.Width + 20;
			GuiCheckBox chkMapping = ui.AddCheckBox( "chkMapping", "Create XML mapping files.", false, "Create an XML file for each table or view selected. (*.hbm.xml)" );
			chkMapping.Width = 150;
			chkMapping.Top = chkClass.Top + 20;
			chkMapping.Left = chkClass.Left;
			
			GuiLabel label6 = ui.AddLabel( "label6", "Read Only:", "Create as read only?" );
			label6.Width = 150;
			label6.Top = label5.Top;
			label6.Left = label5.Left + label5.Width + 20;
			GuiCheckBox chkReadOnly = ui.AddCheckBox( "chkReadOnly", "Create as read-only.", false, "Create object and mapping to have read-only access." );
			chkReadOnly.Width = 150;
			chkReadOnly.Top = chkClass.Top;
			chkReadOnly.Left = chkClass.Left + chkClass.Width + 20;
			
			GuiLabel label9 = ui.AddLabel( "label9", "Use ActiveRecordValidationBase:", "ValidationBase?" );
			label9.Width = 150;
			label9.Top = label5.Top;
			label9.Left = label5.Left + label5.Width + 20;
			GuiCheckBox chkValidationBase = ui.AddCheckBox( "chkValidationBase", "Use ActiveRecordValidationBase.", false, "Inherit from ActiveRecordValidationBase." );
			chkValidationBase.Width = 200;
			chkValidationBase.Top = chkMapping.Top;
			chkValidationBase.Left = chkMapping.Left + chkMapping.Width + 20;
			
			GuiCheckBox chkDefaultEmptyConstructor = ui.AddCheckBox( "chkDefaultEmptyConstructor", "Create a default (empty) constructor.  Required.", true, "Create a default constructor with empty fields." );
			chkDefaultEmptyConstructor.Top = chkMapping.Top + 20;
			GuiCheckBox chkRequiredFieldsConstructor = ui.AddCheckBox( "chkRequiredFieldsConstructor", "Create a constructor with all required (non-null) fields as parameters.", true, "Create a constructor with all required (non-null) fields as parameters" );
			chkRequiredFieldsConstructor.Top = chkDefaultEmptyConstructor.Top + 20;
			GuiCheckBox chkIncludePKInReqFieldsCtorArgs = ui.AddCheckBox( "chkIncludePKInReqFieldsCtorArgs", "Include primary key in required fields constructor.", true, "Include primary key in the parameter list for the required fields constructor." );
			chkIncludePKInReqFieldsCtorArgs.Top = chkRequiredFieldsConstructor.Top + 20;
			GuiCheckBox chkEqualsHashCode = ui.AddCheckBox( "chkEqualsHashCode", "Create Equals and GetHashCode.", true, "Generate Equals and GetHashCode methods." );
			chkEqualsHashCode.Top = chkIncludePKInReqFieldsCtorArgs.Top + 20;
	
	
			// Setup Tables selection multi-select listbox.
			GuiLabel label7 = ui.AddLabel( "label7", "Select tables:", "Select tables from the listbox below." );
			label7.Top = chkEqualsHashCode.Top + 20;
			GuiListBox chooseTables = ui.AddListBox( "chooseTables", "Select tables." );
			chooseTables.Height = 150;
	
			// Setup Views selection multi-select listbox.
			GuiLabel label8 = ui.AddLabel( "label8", "Select views:", "Select views from the listbox below." );
			GuiListBox chooseViews = ui.AddListBox( "chooseViews", "Select views." );
			chooseViews.Height = 80;
			
			// Attach the onchange event to the cmbDatabases control.
			setupDatabaseDropdown( chooseDatabase );
			chooseDatabase.AttachEvent( "onchange", "chooseDatabase_onchange" );
	
			ui.ShowGui = true;
		}
		else 
		{
			ui.ShowGui = false;
		}
	}
	
	public void setupDatabaseDropdown( GuiComboBox Databases )
	{
		try 
		{	
			if( MyMeta.IsConnected )
			{
				Databases.BindData( MyMeta.Databases );
				if( MyMeta.DefaultDatabase != null ) 
				{
					Databases.SelectedValue = MyMeta.DefaultDatabase.Alias;
					bindTables( Databases.SelectedValue );
					bindViews( Databases.SelectedValue );
				}
			}
		}
		catch
		{
		}
	}
	
	public void bindTables( string sDatabase )
	{
		int count = 0;
	
		GuiListBox lstTables = ui["chooseTables"] as GuiListBox;
		
		try 
		{	
			IDatabase db = MyMeta.Databases[sDatabase];
			lstTables.BindData( db.Tables );
		}
		catch
		{
		}
	}
	
	public void bindViews( string sDatabase )
	{
		int count = 0;
	
		GuiListBox lstViews = ui["chooseViews"] as GuiListBox;
		
		try 
		{	
			IDatabase db = MyMeta.Databases[sDatabase];
			lstViews.BindData( db.Views );
		}
		catch
		{
		}
	}
	
	public void chooseDatabase_onchange( GuiComboBox control )
	{
		int count = 0;

		GuiComboBox cmbDatabases = ui["chooseDatabase"] as GuiComboBox;
	
		bindTables( cmbDatabases.SelectedText );
		bindViews( cmbDatabases.SelectedText );
	}
	
}
##|GUI_END
##|BODY_MODE Markup
##|BODY_ENGINE .Net Script
##|BODY_LANGUAGE C#
##|BODY_TAG_START <%
##|BODY_TAG_END %>
##|BODY_BEGIN
<%#NAMESPACE System.IO, System.Text, System.Text.RegularExpressions, System.Globalization %><%
public class GeneratedTemplate : DotNetScriptTemplate
{
	private ArrayList _selectedTables;
	private ArrayList _selectedViews;
	private string _dbName;
	private string _tableName;
	private string _className;
	private IColumn _primaryKeyColumn; // Single primary key column.
	private string _exportPath;
	private string _fileName;
	private string _nameSpace;
	private string _prefix;
	private string _using;
	private bool _createClassFiles;
	private bool _createXmlFiles;
	private bool _createReadOnly;
	private bool _generateEqualsHashCode;
	private bool _generateDefaultCtor;
	private bool _generateRequiredFieldsCtor;
	private bool _includePKInReqFieldsCtorArgs;
	private bool _useValidationBase;
	
	// In case if your tables have standard prefixes and you want
	// to remove them from classes, change this.
	private string _tablePrefixRemoval;
	private string _tablePrefixSubstitue;
	
	public GeneratedTemplate( ZeusContext context ) : base( context ) {}

	public override void Render()
	{
		_dbName = input["chooseDatabase"].ToString();
		_selectedTables = input["chooseTables"] as ArrayList;
		_selectedViews = input["chooseViews"] as ArrayList;
		_exportPath = input["outputPath"].ToString();
		_nameSpace = input["classNamespace"].ToString();
		_using = input["classUsing"].ToString();
		_prefix = input["memberPrefix"].ToString();
		_tablePrefixRemoval = input["classDBPrefix"].ToString();
		if(_tablePrefixRemoval.Length <= 0)
		 _tablePrefixRemoval = null;
		_tablePrefixSubstitue = input["classDBPrefixRpl"].ToString();
		_createClassFiles = (bool)input["chkClass"];
		_createXmlFiles = (bool)input["chkMapping"];
		_createReadOnly = (bool)input["chkReadOnly"];
		_useValidationBase = (bool)input["chkValidationBase"];
		_generateEqualsHashCode = (bool)input["chkEqualsHashCode"];
		_generateDefaultCtor = (bool) input["chkDefaultEmptyConstructor"];
		_generateRequiredFieldsCtor = (bool) input["chkRequiredFieldsConstructor"];
		_includePKInReqFieldsCtorArgs = (bool) input["chkIncludePKInReqFieldsCtorArgs"];
		
		
		foreach( string _newTable in _selectedTables )
		{
			ITable _workingTable = MyMeta.Databases[_dbName].Tables[_newTable];
			_tableName = _workingTable.Alias.Replace( " ", "" );
			_className = ToPascalCase( _tableName );
			if( _createClassFiles )
			{
				GenerateClassFile( _workingTable.Columns );
			}
			if( _createXmlFiles )
			{
				GenerateMappingFile( _workingTable.Columns );
			}
		}
		
		foreach( string _newView in _selectedViews )
		{
			IView _workingView = MyMeta.Databases[_dbName].Views[_newView];
			_tableName = _workingView.Alias.Replace( " ", "" );
			_className = ToPascalCase( _tableName );
			if( _createClassFiles )
			{
				GenerateClassFile( _workingView.Columns );
			}
			if( _createXmlFiles )
			{
				GenerateMappingFile( _workingView.Columns );
			}
		}
	}
	
	private void GenerateClassFile( IColumns Columns )
	{
		output.writeln( "using System;" );
		output.writeln( "using System.Collections;" );
		output.writeln( "using System.Collections.Generic;" );
		output.writeln( "using System.Text;" );
		output.writeln( "using Castle.ActiveRecord;" );
		output.writeln( "using Castle.ActiveRecord.Queries;" );
		output.writeln( "using NHibernate.Expression;" );
		output.writeln( "using NHibernate.Generics;" );

		output.writeln( _using);
		output.writeln( "" );
		GenerateClassTableHeader( Columns );	
		output.writeln( "/// <summary>" );
		output.writeln( "///\tGenerated by MyGeneration using the ActiveRecord Object Mapper - 1.0.2" );
		output.writeln( "///\tCreated on " + DateTime.Now );
		output.writeln( "/// </summary>" );
		output.write( "namespace " );
		output.writeln( _nameSpace );
		output.writeln( "{" );
		output.write( "\t[Serializable , ActiveRecord(\"");
		output.write(_tableName);
		output.writeln("\", DynamicUpdate = true, Lazy = true)]" );
		output.write( "\tpublic class " );
		output.write( _className );
		if(_useValidationBase)
			output.writeln( " : ActiveRecordValidationBase\t{" );
		else
			output.writeln( " : ActiveRecordBase\t{" );
		
		BuildPrivateMembers( Columns );
		%>
		#region Constuctor(s)
		<%
		if( _generateDefaultCtor )
			BuildDefaultConstructor( Columns );
		
		if( _generateRequiredFieldsCtor )
			BuildRequiredFieldsCtor( Columns );
		%>
		#endregion // End of Class Constuctor(s)
		<%
		BuildPublicAccessors( Columns );

		//BuildInternalAccessors( Columns );
		
		//BuildPublicFunctions (Columns);
		
		if( _generateEqualsHashCode ) 
			BuildEqualsHashCodeOverrides( Columns );
		
		output.writeln( "\t}" );
		output.writeln( "}" );
		
		_fileName = _className + ".cs";
		output.save( Path.Combine( _exportPath, _fileName ), false );
		output.clear();
	}
	
	private void GenerateClassTableHeader( IColumns Columns )
	{
		output.writeln( "#region '" + _tableName + "' Schema");
		output.writeln( "/*");
		output.writeln( " * '" + _className + "' class maps to '"+ _tableName + "' table.");
		foreach( IColumn field in Columns )
		{
			string propertyName = field.Name;// + "(" + ColumnToPropertyName( field )+")";
			string fpname = String.Format("{0,-24}", propertyName);
			output.write(" * \t " + fpname);
			output.write("| Type:" + String.Format("{0,-10}",field.DataTypeName));
			output.write("| Len:" + String.Format("{0,-6}",field.CharacterMaxLength));
			output.write("| Nullable:" + String.Format("{0,-1}",field.IsNullable?"T":"F"));
			output.write(" | PK:" + String.Format("{0,-1}",field.IsInPrimaryKey?"T":"F"));
			output.write(" | FK:" + String.Format("{0,-1}",field.IsInForeignKey?"T":"F"));
			output.writeln("");
		}
		output.writeln( " */");
		output.writeln( "#endregion");
	}	
	
	private void GenerateMappingFile( IColumns Columns )
	{
		BuildHBMDefinition( Columns );
		
		_fileName = _className + ".hbm.xml";
		output.save( Path.Combine( _exportPath, _fileName ), false );
		output.clear();
	}
	
	
	private void BuildDefaultConstructor( IColumns Columns )
	{
		%>
		public <%= _className %>()
		{<%
		foreach( IColumn field in Columns )
		{
			string fieldName = ColumnToMemberVariable( field );
			string fieldType = ( field.IsInForeignKey && !field.IsInPrimaryKey ? ColumnFKToClassName( field) : ColumnToNHibernateType( field ) );
			if( fieldType.EndsWith( "[]" ) )
			{%>
			<%= fieldName %> = new <%= fieldType %>{}; <%
			}
			else
			{
				switch( fieldType )
				{
					case "string":%>
			<%= fieldName %> = String.Empty; <%
						break;
					case "DateTime":%>
			<%= fieldName %> = DateTime.MinValue; <%
						break;
					case "bool":%>
			<%= fieldName %> = false; <%
						break;
					case "decimal":
					case "float":
					case "short":
					case "int":
					case "long":%>
			<%= fieldName %> = 0; <%
						break;
					default:%>
			<%= fieldName %> = new <%= fieldType %>(); <%
						break;
				}
			}
		}
		output.writeln("");
		foreach( IColumn field in Columns )
		{
			if(field.IsInPrimaryKey)
				_primaryKeyColumn = field;
			if( field.IsInForeignKey && field.IsInPrimaryKey )
			{
				//Here, there are foreign key relationships to this column, 
				//so there are collections in this class that represent those relationships. 
				//Initialize them.  
				foreach( IForeignKey fk in field.ForeignKeys )
				{
					string fkclassname = ToPascalCase(fk.ForeignTable.Alias);
					if(_tableName.Equals(fk.ForeignTable.Alias))
					{					
						string refName = fk.ForeignColumns[0].Name;
						output.writeln("");
						output.write("\t\t\t");
						output.write( _prefix );
						output.write( "_child" );
						output.write( ConvertToPlural(ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ));
						output.writeln( " = new EntitySet<" + ToPascalCase(fk.ForeignTable.Alias)+">(");
						output.writeln( "\t\t\t\tdelegate(" + fkclassname + " obj) { obj." + ToPascalCase(refName)+" = this; },");
						output.writeln( "\t\t\t\tdelegate(" + fkclassname + " obj) { obj." + ToPascalCase(refName)+" = null; }, InitializeOnLazy.Always);");
					} else 
					{
				
						string fktableClassName = ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ));
						string ftAlias =  ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ;
						if(_tableName.Equals(fk.ForeignTable.Alias))
						{
							ftAlias = "child" + ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) );
							fktableClassName = "Child" + fktableClassName;
						}
					
						// Check whether this can be a HasAndBelongsToMany relationship.
						if(fk.ForeignTable.Columns.Count == fk.ForeignTable.ForeignKeys.Count &&
							fk.ForeignTable.Columns.Count == 2)
						{
							IColumn fkFkColumn = null;
							foreach(IColumn ic in fk.ForeignTable.Columns)
							{
								//if(ic.IsInForeignKey && ic.IsInPrimaryKey)
								//output.writeln("//" + ic.Name);
								if(!ic.Name.Equals(_primaryKeyColumn.Name))
								{
									fkFkColumn = ic;
									break;
								}
							}
							string refClassName = ToPascalCase(fkFkColumn.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ));
							string refVarName = ToCamelCase(fkFkColumn.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ));								
							ftAlias =  ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ;
							if(_tableName.Equals(fk.ForeignTable.Alias))
								ftAlias = "child" + ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) );
							//output.writeln("");
							//output.write( "\t\tprivate EntitySet<" +refClassName+"> ");
							//output.write( _prefix );
							// _ as prefix is required for supporting EntitySet with Generics.
							//output.write( "_" + ftAlias );
							//output.write( "s; " );	
							
							output.writeln("");
							output.write("\t\t\t");
							output.write( _prefix );
							output.write( "_" );
							output.write( ConvertToPlural(refVarName) );
							output.writeln( " = new EntitySet<" + refClassName+">(");
							//May need to fix _classname with proper column name in Many-to-Many relation.
							output.writeln( "\t\t\t\tdelegate(" + refClassName + " obj) { obj." + _className+"s.Add(this); },");
							output.writeln( "\t\t\t\tdelegate(" + refClassName + " obj) { obj." + _className+"s.Remove(this); }, InitializeOnLazy.Always);");
					
						} 
						else 
						{			
							//Many-to-one.
							output.writeln("");
							output.write("\t\t\t");
							output.write( _prefix );
							output.write( "_" );
							output.write( ConvertToPlural(ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ));
							output.writeln( " = new EntitySet<" + ToPascalCase(fk.ForeignTable.Alias)+">(");
							output.writeln( "\t\t\t\tdelegate(" + fkclassname + " obj) { obj." + ColumnToPropertyName(field)+ " = this;  },");
							output.writeln( "\t\t\t\tdelegate(" + fkclassname + " obj) { obj." + ColumnToPropertyName(field)+ " = null; }, InitializeOnLazy.Always);");
				
						}
					}
				}
			}
		}
		output.writeln( "" );
		output.writeln( "\t\t}" );
		//output.writeln( "\t\t#endregion // End of Default ( Empty ) Class Constuctor" );		
	}
	
	private void BuildRequiredFieldsCtor( IColumns Columns )
	{
		//If there are no required fields, don't make a ctor.
		//Doing so will give a compiler error, since the result will
		//have the same signature as the default ctor. 
		if( CountRequiredFields( Columns ) == 0 )
			return;
	
		output.writeln( "" );
		//output.writeln( "\t\t#region Required Fields Only Constructor" );
		//output.writeln( "\t\t/// <summary>" );
		//output.writeln( "\t\t/// required (not null) fields only constructor" );
		//output.writeln( "\t\t/// </summary>" );
		output.write( "\t\tpublic " );
		output.write( _className ); 
		output.writeln( "(" );

		bool first = true;
		foreach( IColumn col in Columns )
		{
			if( !col.IsNullable && ( !col.IsInPrimaryKey || _includePKInReqFieldsCtorArgs ) )
			{
				if( !first ) 
				{
					output.writeln( ", " );
				}
				output.write( "\t\t\t" );

				if( col.IsInForeignKey && !col.IsInPrimaryKey )
					output.write( ColumnFKToClassName( col ) );
				else
					output.write( ColumnToNHibernateType( col ) );
					
				output.write( " " + ColumnToArgumentName( col ) );
				first = false;
			}
		}
		output.writeln( ")" );
		output.writeln( "\t\t\t: this()" );
		output.writeln( "\t\t{" );

		foreach( IColumn col in Columns )
		{
			if( col.IsInPrimaryKey && !_includePKInReqFieldsCtorArgs )
			{
				//Skip the primary key field, if instructed to do so.
				continue;
			}

			output.write( "\t\t\t" );
			
			if( !col.IsNullable && ( !col.IsInPrimaryKey || _includePKInReqFieldsCtorArgs ) )
			{
				output.write( ColumnToMemberVariable( col ) );
				output.write( " = " );
				output.write( ColumnToArgumentName( col ) );				
				output.writeln( ";" );	
			}
			else
			{
				string fieldType = ( col.IsInForeignKey && !col.IsInPrimaryKey 
					? ColumnFKToClassName( col ) 
					: ColumnToNHibernateType( col ) );
			
				switch( fieldType )
				{
					default:
						output.write( ColumnToMemberVariable( col ) );
						output.writeln( " = null;" );
						break;						
					case "string":
						output.write( ColumnToMemberVariable( col ) );
						output.writeln( " = String.Empty;" );
						break;
					case "DateTime":
						output.write( ColumnToMemberVariable( col ) ); 
						output.writeln( " = DateTime.MinValue;" );
						break;
					case "bool":
						output.write( ColumnToMemberVariable( col ) );
						output.writeln( " = false;" );
						break;
					case "decimal":
					case "float":
					case "short":
					case "int":
					case "long":
						output.write( ColumnToMemberVariable( col ) );
						output.writeln( " = 0;" );
						break;
				}
			}
		}
		foreach( IColumn field in Columns )
		{
			if( field.IsInForeignKey && field.IsInPrimaryKey )
			{
				//Here, there are foreign key relationships to this column, 
				//so there are collections in this class that represent those relationships. 
				//Initialize them.  
				foreach( IForeignKey fk in field.ForeignKeys )
				{
					string fkclassname = ToPascalCase(fk.ForeignTable.Alias);
					if(_tableName.Equals(fk.ForeignTable.Alias))
					{					
						string refName = fk.ForeignColumns[0].Name;
						output.writeln("");
						output.write("\t\t\t");
						output.write( _prefix );
						output.write( "_child" );
						output.write( ConvertToPlural(ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ));
						output.writeln( " = new EntitySet<" + ToPascalCase(fk.ForeignTable.Alias)+">(");
						output.writeln( "\t\t\t\tdelegate(" + fkclassname + " obj) { obj." + ToPascalCase(refName)+" = this; },");
						output.writeln( "\t\t\t\tdelegate(" + fkclassname + " obj) { obj." + ToPascalCase(refName)+" = null; }, InitializeOnLazy.Always);");
					} else 
					{
				
						string fktableClassName = ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ));
						string ftAlias =  ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ;
						if(_tableName.Equals(fk.ForeignTable.Alias))
						{
							ftAlias = "child" + ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) );
							fktableClassName = "Child" + fktableClassName;
						}
					
						// Check whether this can be a HasAndBelongsToMany relationship.
						if(fk.ForeignTable.Columns.Count == fk.ForeignTable.ForeignKeys.Count &&
							fk.ForeignTable.Columns.Count == 2)
						{
							IColumn fkFkColumn = null;
							foreach(IColumn ic in fk.ForeignTable.Columns)
							{
								//if(ic.IsInForeignKey && ic.IsInPrimaryKey)
								//output.writeln("//" + ic.Name);
								if(!ic.Name.Equals(_primaryKeyColumn.Name))
								{
									fkFkColumn = ic;
									break;
								}
							}
							string refClassName = ToPascalCase(fkFkColumn.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ));	
							string refVarName = ToCamelCase(fkFkColumn.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ));									
							
							ftAlias =  ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ;
							if(_tableName.Equals(fk.ForeignTable.Alias))
								ftAlias = "child" + ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) );
							//output.writeln("");
							//output.write( "\t\tprivate EntitySet<" +refClassName+"> ");
							//output.write( _prefix );
							// _ as prefix is required for supporting EntitySet with Generics.
							//output.write( "_" + ftAlias );
							//output.write( "s; " );	
							
							output.writeln("");
							output.write("\t\t\t");
							output.write( _prefix );
							output.write( "_" );
							output.write( ConvertToPlural(refVarName) );
							output.writeln( " = new EntitySet<" + refClassName+">(");
							//May need to fix _classname with proper column name in Many-to-Many relation.
							output.writeln( "\t\t\t\tdelegate(" + refClassName + " obj) { obj." + _className+"s.Add(this); },");
							output.writeln( "\t\t\t\tdelegate(" + refClassName + " obj) { obj." + _className+"s.Remove(this); }, InitializeOnLazy.Always);");
					
						} 
						else 
						{						
							//Many-to-one.
							output.writeln("");
							output.write("\t\t\t");
							output.write( _prefix );
							output.write( "_" );
							output.write( ConvertToPlural(ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) )) );
							output.writeln( " = new EntitySet<" + ToPascalCase(fk.ForeignTable.Alias)+">(");
							output.writeln( "\t\t\t\tdelegate(" + fkclassname + " obj) { obj." + ColumnToPropertyName(field)+ " = this;  },");
							output.writeln( "\t\t\t\tdelegate(" + fkclassname + " obj) { obj." + ColumnToPropertyName(field)+ " = null; }, InitializeOnLazy.Always);");
				
						}
					}
				}
			}
		}
		output.writeln( "\t\t}" );
		//output.writeln( "\t\t#endregion // End Constructor" );
	}
	
	private void BuildFullConstructor( IColumns Columns )
	{
		%>
		/// <summary>
		/// full constructor
		/// </summary>
		public <%= _className %>(<%
		bool first = true;
		foreach( IColumn field in Columns )
		{
			if( !first ) output.write( ", " );
			output.write( ( field.IsInForeignKey && !field.IsInPrimaryKey ? ToPascalCase( field.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ) ) : ColumnToNHibernateType( field ) ) + " " + ColumnToArgumentName( field ) );
			first = false;
		}%>)
		{<%
				foreach( IColumn col in Columns )
				{
					%>
			<%= ColumnToMemberVariable( col ) %> = <%= ColumnToArgumentName( col ) %>; <%
				}
			%>
		}
		<%
	}
	
	private void BuildEqualsHashCodeOverrides( IColumns Columns )
	{
		%>
			
		#region Equals, HashCode and ToString overrides
		
		/// <summary>
		/// Local implementation of Equals based on unique value members
		/// </summary>
		public override bool Equals( object obj )
		{
			if( this == obj ) return true;
			if( ( obj == null ) || ( obj.GetType() != this.GetType() ) ) return false;
			<%= _className %> castObj = (<%= _className %>)obj; <%
		if( CountUniqueFields( Columns ) == 0 )
		{%>
			return castObj.GetHashCode() == this.GetHashCode()<%
		}
		else
		{%>
			return ( castObj != null )<%
			foreach( IColumn c in Columns )
			{
				if( c.IsInPrimaryKey )
				{
				%> &&
				( this.<%= ColumnToMemberVariable( c ) %> == castObj.<%= ColumnToPropertyName( c ) %> )<%
				}
			}
		} %>;
		}
		
		/// <summary>
		/// Local implementation of GetHashCode based on unique value members
		/// </summary>
		public override int GetHashCode()
		{
			<% if( CountUniqueFields( Columns ) == 0 )
			{
				%>return this.GetType().FullName.GetHashCode();
				<%
			}
			else
			{%>
			int hash = 57; <%
				foreach( IColumn c in Columns )
				{
					if( c.IsInPrimaryKey )
					{
			%>
			hash = 27 * hash * <%= ColumnToMemberVariable( c ) %>.GetHashCode();<%
					}
				}
				%>
			return hash; <%
			}%>
		}
		
		/// <summary>
		/// Local implementation of ToString based on class members
		/// </summary>
		public override String ToString()
        {
            StringBuilder sbuffer = new StringBuilder();
			sbuffer.Append("{");
			
<%          foreach( IColumn c in Columns )
			{
%>			sbuffer.AppendFormat("<%= ColumnToPropertyName( c )%> = {0}, ",<%= ColumnToMemberVariable( c )%>);
<%
			}
%>			sbuffer.Append(" }");
			return sbuffer.ToString();
        }
		
		#endregion
<%
	}
	
	private void BuildPrivateMembers( IColumns Columns )
	{
		if( Columns.Count > 0 )
		{
			%>
		#region Private Members
<%		

		foreach( IColumn field in Columns )
		{
			if(field.IsInPrimaryKey)
				_primaryKeyColumn = field;
			if( field.IsInForeignKey )
			{
				if ( !field.IsInPrimaryKey )
				{
				}
				else
				{
					//A column that's in a fk and in the pk represents a fk relationship
					//from another table, a one-to-many relationship.  (This might be 
					//a bad assumption for a table with a composite primary key.)
					//So we have to add the pk member variable itself...
					%>
		private <%= ColumnToNHibernateType( field ) %> <%= ColumnToMemberVariable( field ) %>; <%
					
				}
			}
		}

		foreach( IColumn field in Columns )
		{
			if( field.IsInForeignKey )
			{
				if ( !field.IsInPrimaryKey )
				{
					// A column that's in a fk but not in the pk is an actual foreign key, 
					// a many-to-one relationship.  So the member variable is a class instance.
				%>
		private <%= ToPascalCase( field.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ) ) %> <%= ColumnToMemberVariable( field ) %>; <%
				}
			}
		}
		
		foreach( IColumn field in Columns )
		{
			if( !field.IsInForeignKey )
			{%>
		private <%= ColumnToNHibernateType( field ) %> <%= ColumnToMemberVariable( field ) %>; <%
			}
		}
		
		output.writeln("");
		foreach( IColumn field in Columns )
		{
			if( field.IsInForeignKey )
			{
				if ( !field.IsInPrimaryKey )
				{
				}
				else
				{
					//... and then we have to add collections for the foreign tables. 
					foreach( IForeignKey fk in field.ForeignKeys )
					{
						string fktableClassName = ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ));
						string ftAlias =  ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ;
						if(_tableName.Equals(fk.ForeignTable.Alias))
						{
							ftAlias = "child" + ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) );
							fktableClassName = "Child" + fktableClassName;
						}
						
						// Check whether this can be a HasAndBelongsToMany relationship.
						if(fk.ForeignTable.Columns.Count == fk.ForeignTable.ForeignKeys.Count &&
							fk.ForeignTable.Columns.Count == 2)
						{
							IColumn fkFkColumn = null;
							foreach(IColumn ic in fk.ForeignTable.Columns)
							{
								//if(ic.IsInForeignKey && ic.IsInPrimaryKey)
								//output.writeln("//" + ic.Name);
								if(!ic.Name.Equals(_primaryKeyColumn.Name))
								{
									fkFkColumn = ic;
									break;
								}
							}
							string refClassName = ToPascalCase(fkFkColumn.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ));						
							string refVarName= ToCamelCase(fkFkColumn.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ));	
							ftAlias =  ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ;
							if(_tableName.Equals(fk.ForeignTable.Alias))
								ftAlias = "child" + ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) );
							output.writeln("");
							output.write( "\t\tprivate EntitySet<" +refClassName+"> ");
							output.write( _prefix );
							// _ as prefix is required for supporting EntitySet with Generics.
							output.write( "_" + ConvertToPlural(refVarName) );
							output.write( "; " );	
						} 
						else 
						{						
							ftAlias =  ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ;
							if(_tableName.Equals(fk.ForeignTable.Alias))
								ftAlias = "child" + ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) );
							output.writeln("");
							output.write( "\t\tprivate EntitySet<" +  ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) )+"> ");
							output.write( _prefix );
							// _ as prefix is required for supporting EntitySet with Generics.
							output.write( "_" + ConvertToPlural(ftAlias ));
							output.write( "; " );	
						}					
					}
				}
			}
		}
%>		
		#endregion
<%
		}
	}
	
	private void BuildPublicAccessors( IColumns Columns )
	{
		if( Columns.Count > 0 )
		{
			%>
		#region Public Properties
			<%
			
			foreach( IColumn field in Columns )
			{
				string fieldAccessor = ColumnToPropertyName( field );
				string fieldName = ColumnToMemberVariable( field );
				string fieldType = ( field.IsInForeignKey && !field.IsInPrimaryKey ? ToPascalCase( field.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ) ) : ColumnToNHibernateType( field ) );
				
				output.writeln( "" );
				//output.writeln( "\t\t/// <summary>" );

				//foreach( string s in field.Description.Split( new char[] { '\n' } ) )
				//{
				//		output.writeln( "\t\t/// " + s );
				//}
				//output.writeln( "\t\t/// </summary>" );
				
				output.writeln( ActiveRecordColumnAttributes( field ));
				output.writeln( "\t\tpublic virtual " + fieldType + " " + fieldAccessor );
				output.writeln( "\t\t{" );
				output.writeln( "\t\t\tget { return " + fieldName + "; }" );
				if( !_createReadOnly )
				output.writeln( "\t\t\tset { " + fieldName + " = value; }" );
				output.writeln( "\t\t}");
			}
			
			
			foreach( IColumn field in Columns )
			{
				string fieldAccessor = ColumnToPropertyName( field );
				string fieldName = ColumnToMemberVariable( field );
				string fieldType = ( field.IsInForeignKey && !field.IsInPrimaryKey ? ToPascalCase( field.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ) ) : ColumnToNHibernateType( field ) );
				//output.writeln( "\t\t/// <summary>" );
				//foreach( string s in field.Description.Split( new char[] { '\n' } ) )
				//{
				//		output.writeln( "\t\t/// " + s );
				//}
				//output.writeln( "\t\t/// </summary>" );

//				if( field.IsInForeignKey && field.IsInPrimaryKey )
//				{
					//This means that there are collections implementing 
					//one-to-many relationships based on this column.  So 
					//we need accessors for those collections, too. 
					//foreach( IForeignKey fk in field.ForeignKeys )
					//{
					////	output.writeln("");
					//	output.write( "\t\tpublic virtual " );
					//	output.write( ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) );
					//	output.write( "[] " );	
					//	output.write( "GetReadOnly" + ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) ));	
					//	output.writeln( "s()" );
//				}
				
				if( field.IsInForeignKey && field.IsInPrimaryKey )
				{
					//This means that there are collections implementing 
					//one-to-many relationships based on this column.  So 
					//we need accessors for those collections, too. 
					foreach( IForeignKey fk in field.ForeignKeys )
					{
						string fktableClassName = ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ));
						string ftAlias =  ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) ;
						if(_tableName.Equals(fk.ForeignTable.Alias))
						{
							ftAlias = "child" + ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) );
							fktableClassName = "Child" + fktableClassName;
						}
						
						// Check whether this can be a HasAndBelongsToMany relationship.
						if(fk.ForeignTable.Columns.Count == fk.ForeignTable.ForeignKeys.Count &&
							fk.ForeignTable.Columns.Count == 2)
						{
						IColumn fkFkColumn = null;
						foreach(IColumn ic in fk.ForeignTable.Columns)
						{
							//if(ic.IsInForeignKey && ic.IsInPrimaryKey)
							//output.writeln("//" + ic.Name);
							if(!ic.Name.Equals(_primaryKeyColumn.Name))
							{
								fkFkColumn = ic;
								break;
							}
						}
						//output.writeln("//" + fkFkColumn.Name);	
						//output.writeln("//" + fkFkColumn.ForeignKeys[0].PrimaryTable.Alias);
						//  [HasAndBelongsToMany(typeof(User) , Table = "SC_GROUP_USER" ,
						//	ColumnRef = "USER_ID" , ColumnKey = "GROUP_ID" , Lazy = true , 
						//	Inverse = true, Cascade = ManyRelationCascadeEnum.None, 
						//	CustomAccess = Generics.Access,RelationType = RelationType.Set)]
						string refClassName = ToPascalCase(fkFkColumn.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ));
						string refVarName = ToCamelCase(fkFkColumn.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ));
						output.writeln("");
						output.write("\t\t[HasAndBelongsToMany(typeof("+refClassName+") , Table = \"");
						output.writeln(fk.ForeignTable.Alias +"\" , ColumnRef = \"" + fkFkColumn.Name +"\",");
						output.writeln("\t\tColumnKey = \"" + fk.ForeignColumns[0].Name +"\" , Inverse = true , Lazy = true, Cascade = ManyRelationCascadeEnum.None,");
						output.writeln("\t\tCustomAccess = Generics.Access , RelationType = RelationType.Set)]");
						
						output.write( "\t\tpublic virtual ICollection<" +refClassName+"> " );
						output.write( ConvertToPlural(refClassName) );
						output.writeln( " " );	
%>		{	
			get { return _<%=ConvertToPlural(refVarName)%>; }
		}
<%
						} 
						else 
						{						
						output.writeln("");
						output.writeln("\t\t[HasMany(typeof("+ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ))+") , Table = \"" + fk.ForeignTable.Alias +"\" , ColumnKey = \"" + fk.ForeignColumns[0].Name +"\" , Inverse = true , Lazy = true,");
						output.writeln("\t\tCascade = ManyRelationCascadeEnum.None, CustomAccess = Generics.Access , RelationType = RelationType.Set)]");
						
						output.write( "\t\tpublic virtual ICollection<" +ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ))+"> " );
						output.write( ConvertToPlural(fktableClassName) );
						output.writeln( " " );	
%>		{	
			get { return _<%=ConvertToPlural(ftAlias)%>; }
		}
<%
						}
					}
				}
			}
			
			%>

		#endregion 
<%
		}
	}
		
	
	private void BuildPublicFunctions( IColumns Columns )
	{
	if( Columns.Count > 0 )
		{
%>
		#region Public Functions
<%
			foreach( IColumn field in Columns )
			{
				string fieldAccessor = ColumnToNHibernateProperty( field );
				string fieldName = ColumnToMemberVariable( field );
				
				if( field.IsInForeignKey && field.IsInPrimaryKey)
				{
					//This means that there are collections implementing 
					//one-to-many relationships based on this column.  So 
					//we need accessors for those collections, too. 
					foreach( IForeignKey fk in field.ForeignKeys )
					{
					string localvariable = ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) );
%>
		public void Add<%=ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) %>(<%=ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) + " " + localvariable%>)
		{
			if (<%=localvariable%> == null)
				throw new ArgumentNullException("<%=localvariable%>", "Input parameter is null");
			<%=_prefix%><%=ToCamelCase( fk.ForeignTable.Alias.Replace( " ", "" ) )%>s.Add(<%=localvariable%>);
			isChanged |= true;
		}	
<%					}
				}
			}
%>
		#endregion //Public Functions
<%
		}
	}
	
	private void BuildHBMDefinition( IColumns Columns )
	{
		if( Columns.Count > 0 )
		{
			output.writeln( "<?xml version=\"1.0\" encoding=\"utf-8\" ?>" );
			output.writeln( NHibernateMappingTag() );
			output.writeln( "\t" + NHibernateClassTag( Columns ) );
			output.writeln( "\t\t" + NHibernatePrimaryKeysTag( Columns ) );
			output.writeln( "\t\t" + NHibernateProperties( Columns ) );
			output.writeln( "\t</class>" );
			output.writeln( "</hibernate-mapping>" );
		}
	}
	
	private string NHibernateMappingTag()
	{
		//// can't handle external mappings ?!?
		////string xml = "<hibernate-mapping xmlns=\"http://nhibernate.sourceforge.net/schemas/nhibernate-mapping-2.0.xsd\"";
		//string xml = "<hibernate-mapping xmlns=\"urn:nhibernate-mapping-2.0\"";
		//// handle schemas, cascade, import, and access methods?
		//return xml + ">";
		return "<hibernate-mapping xmlns=\"urn:nhibernate-mapping-2.0\" assembly=\"" + _nameSpace + "\" namespace=\"" + _nameSpace + "\">";
	}
	
	private string NHibernateClassTag( IColumns Columns )
	{
		//ITable t = Columns[0].Table;
		//IView v = Columns[0].View;
		//string desc = ( t == null ) ? v.Description : t.Description;
		StringBuilder xml = new StringBuilder();
		xml.Append( "<class name=\"" ).Append( _className ).Append( "\"" );
		xml.Append( " table=\"" ).Append( _tableName ).Append( "\"" );
		if( _createReadOnly )
		{
			xml.Append( " mutable=\"false\"" );
		}
		// handle schema override, dynamic insert & update, and proxies?
		xml.Append( ">\r\n" );
		return xml.ToString();
	}
	
	private string NHibernatePrimaryKeysTag( IColumns Columns )
	{
		StringBuilder xml = new StringBuilder();
		int i = 0;
		foreach( IColumn c in Columns )
		{
			if( c.IsInPrimaryKey )
			{
				i++;
			}
		}
		if( i == 0 )
		{
			return  "<!-- could not find a primary key for this table/view. NHibernate requires an 'id' element, so you'll have to define one manually. -->";
		}
		if( i == 1 )
		{
			foreach( IColumn c in Columns )
			{
				if( c.IsInPrimaryKey )
				{
					xml.Append( "<id name=\"" ).Append( ColumnToPropertyName( c ) ).Append( "\" column=\"" );
					xml.Append( c.Alias ).Append( "\" type=\"" ).Append( ConvertNHibernate( ColumnToNHibernateType( c ) ) ).Append( "\"" );
					switch( ColumnToNHibernateType( c ) )
					{
						case "decimal":
						case "float":
						case "short":
						case "int":
						case "long":
							xml.Append( " unsaved-value=\"0\">\r\n" );
							break;
						default:
							xml.Append( ">\r\n" );
							break;
					}
					xml.Append( "\t\t\t<generator class=\"" );
					xml.Append( ( c.IsAutoKey ) ?  "native" : "assigned" );
					xml.Append( "\"/>\r\n\t\t</id>" );
				}
			}
		}
		if( i > 1 )
		{
			xml.Append( "<!-- composite primary key support is touchy. View the documentation for syntax. -->" );
		}
		return xml.ToString();
	}
	
	private string NHibernateProperties( IColumns Columns )
	{
		StringBuilder xml = new StringBuilder();
		foreach( IColumn c in Columns )
		{
			if( !c.IsInPrimaryKey )
			{
				// create sets & such for foreign keys !!!
				if( c.IsInForeignKey )
				{
					if( c.ForeignKeys.Count > 1 )
					{
						xml.Append( "<!-- more than one foreign column is mapped to " ).Append( c.Name ).Append( " - you're on your own. -->\r\n\t\t" );
					}
					else
					{
						IForeignKey fk = c.ForeignKeys[0];
						xml.Append( "<many-to-one name=\"" )
						   .Append( ColumnToPropertyName( c ) )
						   .Append( "\" column=\"" )
						   .Append( c.Name );
						xml.Append( "\" class=\"" )
						   .Append( ToPascalCase( fk.PrimaryTable.Alias.Replace( " ", "" ) ) )
						   .Append( "\" />\r\n\t\t" );
					}
				}
				else
				{
					xml.Append( "<property name=\"" ).Append( ColumnToPropertyName( c ) ).Append("\" column=\"" ).Append( c.Name );
					xml.Append( "\" type=\"" ).Append( ConvertNHibernate( ColumnToNHibernateType( c ) ) ).Append( "\"" );
					if( _createReadOnly )
					{
						xml.Append( " access=\"field\"").Append( "\"" );
					}
					else
					{
					}
					if( !c.IsNullable )
					{
						xml.Append( " not-null=\"true\"" );
					}
					if( c.LanguageType == "string" )
					{
						xml.Append( " length=\"" ).Append( c.CharacterMaxLength ).Append( "\"" );
					}
					xml.Append( " />\r\n\t\t" );
				}
			}
			else	
			{	
			}
		}
		foreach( IColumn c in Columns )
		{
			if( !c.IsInPrimaryKey )
			{
			}
			else	
			{	// c.IsInPrimaryKey is true here
					if( c.IsInForeignKey )
					{
					//Here's where we handle one-to-many relations.  A column that is in the PK, and is involved in FK relatioships, 
					//means it's the one in the one-to-many. 
					
					foreach( IForeignKey fk in c.ForeignKeys )
					{
						//Use a bag, since we don't know the real relationship.  
						xml.Append( "<bag "); 
						
						//The name for the collection property in the class.  
						//Made from the class name of the "many" side of the 
						//relationship, with "List" appended.  
						xml.Append( "name=\"" )
						   .Append( ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) )
						   .Append( "s\" " );
						   
						//This means that persisting the class obj that contains this 
						//collection will not cause the collection's elements to be persisted.
						//You have to navigate the collection and persist them individually. 
						xml.Append( "inverse=\"true\" " );
						
						//Lazy loading.  The collection is not filled until the application needs it. 
						xml.Append( "lazy=\"true\" " )
						   .Append( ">\r\n" );
						
						//The key element specifies the column in the owning class/table that is the
						//foreign key for the collection's class/table.  Note this code only supports 
						//single-column foreign keys.  
						if( fk.ForeignColumns.Count > 1 )
						{
							xml.Append( "<!-- Composite foreign keys are not supported in this template. -->\r\n" );
						}
						else
						{
							xml.Append( "\t\t\t<key column=\"" )
							   .Append( fk.ForeignColumns[0].Name )
							   .Append( "\" />\r\n" );
						}
						
						//the one-to-many tag specifies the class of the objects in the 
						//collection, the "many" side.  
						xml.Append( "\t\t\t<one-to-many class=\"" )
						   
						   .Append( ToPascalCase( fk.ForeignTable.Alias.Replace( " ", "" ) ) )
						   
						   .Append( "\" />\r\n" );
						
						//Close the bag tag and indent for the next column. 
						xml.Append( "\t\t</bag>\r\n\t\t" );
						}
					}
			}
		}
		return xml.ToString();
	}
	
	private string ActiveRecordColumnAttributes( IColumn c )
	{
			StringBuilder xml = new StringBuilder();
			if( !c.IsInPrimaryKey )
			{
				// create sets & such for foreign keys !!!
				if( c.IsInForeignKey )
				{
					if( c.ForeignKeys.Count > 1 )
					{
						xml.Append( "//<!-- More than one foreign column is mapped to " ).Append( c.Name ).Append( ". Include your own custom attributes. -->\r\n\t\t" );
					}
					else
					{
						// Many-to-One relationship.
						IForeignKey fk = c.ForeignKeys[0];
						xml.Append( "\t\t[BelongsTo(\"" )
						   .Append( c.Name );
						xml.Append( "\")]" );
					}
				}
				else
				{
					// Regular property.
					xml.Append( "\t\t[Property(Column=\"").Append( c.Name ).Append("\"");;
					if( !c.IsNullable )
					{
						xml.Append( ", NotNull=true" );
					}
					if( c.LanguageType == "string" )
					{
						xml.Append( ", Length=" ).Append( c.CharacterMaxLength );
					}
					xml.Append( ")]" );
				}
			}
			else	
			{		// c.IsInPrimaryKey is true. Generate primary key.
					xml.Append( "\t\t[PrimaryKey(PrimaryKeyType.Identity ,\"").Append( c.Name ).Append("\"");;
					
					if( c.LanguageType == "string" )
					{
						xml.Append( ", Length=" ).Append( c.CharacterMaxLength );
					}
					xml.Append( ")]" );
			}
		return xml.ToString();
	}
	
	private string ConvertNHibernate( string Type )
	{
		string retVal = Type;
		
		switch( Type )
		{
			case "bool":
				retVal = "Boolean";
				break;
			case "byte":
				retVal = "Byte";
				break;
			case "sbyte":
				retVal = "SByte";
				break;
			case "char":
				retVal = "Char";
				break;
			case "decimal":
				retVal = "Decimal";
				break;
			case "double":
				retVal = "Double";
				break;
			case "float":
				retVal = "Single";
				break;
			case "int":
				retVal = "Int32";
				break;
			case "uint":
				retVal = "UInt32";
				break;
			case "long":
				retVal = "Int64";
				break;
			case "ulong":
				retVal = "UInt64";
				break;
			case "short":
				retVal = "Int16";
				break;
			case "ushort":
				retVal = "UInt16";
				break;
			case "string":
				retVal = "String";
				break;
		}
		
		return retVal;
	}
	
	private string ColumnToMemberVariable( IColumn Column )
	{
		return ToCamelCase( UniqueColumn( Column ));
	}
	
	private string ColumnToPropertyName( IColumn Column )
	{
		return ToPascalCase( UniqueColumn( Column ) );
	}
	
	private string ColumnFKToClassName( IColumn c )
	{
		return ToPascalCase( c.ForeignKeys[0].PrimaryTable.Alias.Replace( " ", "" ) );
	}
	
	private string ColumnToArgumentName( IColumn Column )
	{
		return UniqueColumn( Column ).ToLower();
	}
	
	private string ColumnToNHibernateProperty( IColumn Column )
	{
		return ToCamelCase( UniqueColumn( Column ));
		//return  UniqueColumn( Column );
	}
	
	private string UniqueColumn( IColumn Column )
	{
		string c = Column.Alias.Replace( " ", "" );
		if( Column.Table != null && Column.Table.Alias.Replace( " ", "" ) == c )
		{
			c += "Name";
		}
		if( Column.View != null && Column.View.Alias.Replace( " ", "" ) == c )
		{
			c += "Name";
		}
		return c;
	}
	
	// nhibernate doesn't have these, so use the existing types
	private string ColumnToNHibernateType( IColumn Column )
	{
		string retVal = Column.LanguageType;
		
		switch( Column.LanguageType )
		{
			case "sbyte":
				retVal = "byte";
				break;
			case "uint":
				retVal = "int";
				break;
			case "ulong":
				retVal = "long";
				break;
			case "ushort":
				retVal = "short";
				break;
		}
		
		return retVal;
	}
	
	private bool IsValueType( string type )
	{
		switch( type )
		{
			case "sbyte":
			case "byte":
			case "short":
			case "ushort":
			case "int":
			case "uint":
			case "long":
			case "ulong":
			case "char":
			case "float":
			case "double":
			case "bool":
			case "decimal":
			case "DateTime":
				return true;
				break;
				
			default:
				return false;
				break;
		}
	}
	
	private string ToLeadingCaps( string name )
	{
		char[] chars = name.ToLower().ToCharArray();
		chars[0] = Char.ToUpper( chars[0] );
		return new string( chars );
	}
	
	private string ToLeadingLower( string name )
	{
		char[] chars = name.ToCharArray();
		chars[0] = Char.ToLower( chars[0] );
		return new string( chars );
	}
	
	/** Babu: This one is used for C# class generation */
	private string ToPascalCase( string name )
	{
		string notStarting_SC = "";
		if(_tablePrefixRemoval != null)
		   notStarting_SC = Regex.Replace( name, _tablePrefixRemoval, _tablePrefixSubstitue );
		else 
		   notStarting_SC = name;
		string notStartingAlpha = Regex.Replace( notStarting_SC, "^[^a-zA-Z]+", "" );
		string workingString = ToLowerExceptCamelCase( notStartingAlpha );
		workingString = RemoveSeparatorAndCapNext( workingString );
		return workingString;
	}
	
	public static string ConvertToPlural(string singular)
        {
            string lower = singular.ToLower();
            string res;

            //rule out a few exceptions
            if (lower.Equals("foot"))
            {
                res = "Feet";
            }
            else if (lower.Equals("goose"))
            {
                res = "Geese";
            }
            else if (lower.Equals("man"))
            {
                res = "Men";
            }
            else if (lower.Equals("woman"))
            {
                res = "Women";
            }
            else if (lower.Equals("criterion"))
            {
                res = "Criteria";
            }
            else if (lower.EndsWith("y") && "aeiou".IndexOf(lower.Substring(lower.Length - 2 , 1)) < 0)
			{
				res = singular.Substring(0 , singular.Length - 1) + "ies";
			}
                       else if (lower.EndsWith("ss")) {
                               res = singular + "es";
                        }
                        else {
                                res = singular + "s";
                        }
						
            //the result must preserve the original word's capitalization
            if (singular.Equals(lower))
            {
                return res.ToLower(); // it was an all-lowercase word
            }
            else if (singular.Equals(singular.ToUpper()))
            {
                return res.ToUpper(); //it was an all-uppercase word
            }
            else
                return res; // return whatever is in "res"
        }
	
	private string ToCamelCase( string name )
	{
		string notStarting_SC = "";
		if(_tablePrefixRemoval != null)
		   notStarting_SC = Regex.Replace( name, _tablePrefixRemoval, _tablePrefixSubstitue );
		else 
		   notStarting_SC = name;
		string notStartingAlpha = Regex.Replace( notStarting_SC, "^[^a-zA-Z]+", "" );
		string workingString = ToLowerExceptCamelCase( notStartingAlpha );
		workingString = RemoveSeparatorAndCapNext( workingString );
		char[] chars = workingString.ToCharArray();
		chars[0] = Char.ToLower( chars[0], CultureInfo.InvariantCulture );
		workingString = new string( chars );
		return workingString;
	}
	
	private string RemoveSeparatorAndCapNext( string input )
	{
		string dashUnderscore = "-_";
		string workingString = input;
		char[] chars = workingString.ToCharArray();
		int under = workingString.IndexOfAny( dashUnderscore.ToCharArray() );
		while( under > -1 )
		{
			chars[ under + 1 ] = Char.ToUpper( chars[ under + 1 ], CultureInfo.InvariantCulture );
			workingString = new String( chars );
			under = workingString.IndexOfAny( dashUnderscore.ToCharArray(), under + 1 );
		}
		chars[ 0 ] = Char.ToUpper( chars[ 0 ], CultureInfo.InvariantCulture );
		workingString = new string( chars );
		return Regex.Replace( workingString, "[-_]", "" );
	}

	private string ToLowerExceptCamelCase( string input )
	{
		char[] chars = input.ToCharArray();
		for( int i = 0; i < chars.Length; i++ )
		{
			int left = ( i > 0 ? i - 1 : i );
			int right = ( i < chars.Length - 1 ? i + 1 : i );
			if( i != left && i != right )
			{
				if( Char.IsUpper( chars[i] ) && Char.IsLetter( chars[ left ] ) && Char.IsUpper( chars[ left ] ) )
				{
					chars[i] = Char.ToLower( chars[i], CultureInfo.InvariantCulture );
				}
				else if( Char.IsUpper( chars[i] ) && Char.IsLetter( chars[ right ] ) && Char.IsUpper( chars[ right ] ) )
				{
					chars[i] = Char.ToLower( chars[i], CultureInfo.InvariantCulture );
				}
				else if( Char.IsUpper( chars[i] ) && !Char.IsLetter( chars[ right ] ) )
				{
					chars[i] = Char.ToLower( chars[i], CultureInfo.InvariantCulture );
				}
			}
		}
		chars[ chars.Length - 1 ] = Char.ToLower( chars[ chars.Length - 1 ], CultureInfo.InvariantCulture );
		return new string( chars );
	}
	
	private int CountRequiredFields( IColumns Columns )
	{
		return Columns.Count - CountNullableFields( Columns );
	}
	
	private int CountNullableFields( IColumns Columns )
	{
		int i = 0;
		foreach( IColumn c in Columns )
		{
			if( c.IsNullable )
			{
				i++;
			}
		}
		return i;
	}
	
	private int CountUniqueFields( IColumns Columns )
	{
		int i = 0;
		foreach( IColumn c in Columns )
		{
			if( !c.IsNullable && c.IsInPrimaryKey )
			{
				i++;
			}
		}
		return i;
	}
}

%>
##|BODY_END
